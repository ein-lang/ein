use crate::types::{self, Type};
use crate::ast::{Expression, FunctionDefinition, Module, Operation, Operator};
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub Module: Module = <FunctionDefinition*> => Module::new(<>);

pub FunctionDefinition: FunctionDefinition = {
  <location: @L> <type_name:Identifier> ":" <type_:FunctionType> ";"
  <name:Identifier> <arguments:Identifier*> "=" <body:Expression> ";" =>? {
    if type_name != name {
      Err(ParseError::InvalidToken { location })
    } else {
      Ok(FunctionDefinition::new(name, arguments, body, type_))
    }
  }
};

pub Expression: Expression = {
  Term2 => <>,
  Operation2 => Expression::Operation(<>),
};

pub Term1: Expression = {
  Number => Expression::Number(<>),
  "(" <Expression> ")" => <>,
};

pub Term2: Expression = {
  Term1 => <>,
  Operation1 => Expression::Operation(<>),
};

Operation1: Operation =
  <e1:Term2> <o:Operator1> <e2:Term1> => Operation::new(o, e1, e2);

Operation2: Operation =
  <e1:Expression> <o:Operator2> <e2:Term2> => Operation::new(o, e1, e2);

Operator1: Operator = {
  "*" => Operator::Multiply,
  "/" => Operator::Divide,
}

Operator2: Operator = {
  "+" => Operator::Add,
  "-" => Operator::Subtract,
};

Number: f64 = r"-?[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap();

Identifier: String = r"[a-zA-Z][a-zA-Z0-9]*" => String::from(<>);

Type: Type = {
  FunctionType => <>.into(),
  AtomicType => <>,
};

FunctionType: types::Function =<AtomicType> "->" <Type> => types::Function::new(<>);

AtomicType: Type = {
  "Number" => Type::Number,
  "(" <Type> ")" => <>,
};
